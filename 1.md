## drf

## flex布局

```css
.menu{
	display: flex;
	/*row：规定主轴方向为水平方向排列*/
	flex-direction:row;
	/*culumn规定主轴方向，竖直方向排列*/
	flex-direction:column;
    /*在主轴方向如何展示*/
	justipy-content:space-around; /*常用的还有flex-start;center;space-between；flex-end*/
	/*在纵轴(副轴)方向如何展示*/
    align-item:center;/*常用的还有flex-start;center;space-between；flex-end*/
}
.imge{
    border-radius:50px; /*半径，圆形*/
}
/* 应用 */
.menu{
	display: flex;
	/*row：规定主轴方向为水平方向排列*/
	flex-direction:row;
    /*在主轴方向如何展示*/
	justipy-content:space-around; 
	
}
.menu .item{
    display: flex;
    /*culumn规定主轴方向，竖直方向排列*/
	flex-direction:column;
    /*在纵轴(副轴)方向如何展示*/
    align-item:center; /*flex-end*/
}
```

## xpath

```python
from lxml import etree
tree = etree.parse('./test.html') # 将本地储存的html文件进行解析
tree = etree.HTML(page_text) # 解析网上爬取的数据

# 标签定位
tree.xpath('/html/head') # 必须从根标签开始逐层定位目标标签
tree.xpath('/html//meta') # 每一个/表示一个层级》》等价于tree.xpath('/html/head/meta')
tree.xpath('//head') # 可以从任意位置定义目标标签》》将html文档中所有的head标签定位到
# 属性定位：//tagName[@attrName='valus']
#定位class为song的div 
tree.xpath('//div[@class="song"]')

# 索引定位：//tagName[index] 索引从1开始，不是从0
tree.xpath('//li[3]') 
# 模糊匹配：
tree.xpath('//div[contains(@class, "ng")]')  # 包含ng
tree.xpath('//div[starts-with(@class, "ng")]') # 以ng开头

# 数据提取
tree.xpath('//a(@id="feng"/text()') # 直系的文本内容,为列表类型
tree.xpath('//a(@id="feng"//text()') # 所有文本内容,为列表类型     
tree.xpath('//a(@id="feng"/@href') # id=feng的a标签的href属性  (tagName/@attrName)

```























